# Log 2026-01-16

## Summary
Today we made significant progress in transforming the LLM integration from a passive text generator into an **Agentic GenUI System**.

### 1. Agentic Architecture
- **System Prompt**: Created `genui_system_prompt.dart` to define the "Agent" persona and available tools (`InfoCard`, `StatusBadge`).
- **Structured Output**: Enforced a strict JSON schema (`{ text, ui_components }`) so the app can reliably parse responses.
- **JSON Parsing**: Updated `RealGenUiContentGenerator` to extract UI components from the JSON and map them to `A2uiMessage`s.

### 2. Bug Fixes & Debugging
- **Crash Fix**: Resolved "Bad state" errors by managing stream controller lifecycle and ensuring unique Surface IDs.
- **"Ghost Widget" / State Collision**:
    - **Issue**: Historical widgets in the chat would update to match the content of the *newest* response.
    - **Cause**: All generated GenUI responses were reusing the same static `surfaceId` ("dynamic_surface"). Since GenUI surfaces listen to a stream by ID, *all* of them (past and present) would update when a new message with that ID arrived.
    - **Fix**: Implemented **Unique Surface IDs** (timestamp-based) for every response in `RealGenUiContentGenerator`. Each chat bubble now renders a distinct surface.

### 3. Roadmap
- Created `docs/genui_widget_roadmap.md` outlining future components: Charts, Calendar, Reminders, and Rich Actions.

## Next Steps
- Implement the "Chart" components (using `fl_chart`).
- Test the bi-directional sync for Reminders (checking a box updates the state).

### 4. Future Considerations: Chat History & State Persistence
- **Requirement**: The app currently does not persist chat history between sessions.
- **Challenge**: Persisting GenUI widgets is complex because they have **internal state** (e.g., a "Permission Denied" toggle or a "Task Completed" checkbox).
- **Goal**:
    - Save the structural `A2uiMessage` data (JSON) alongside text.
    - Track widget state changes so that reloading the history reflects the *last known state* of the interaction, not just the initial generation.
    - Requires a local database (e.g., Drift/Isar) to store the complex JSON blobs and potentially a "State Snapshot" system.
